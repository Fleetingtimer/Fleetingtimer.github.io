<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[详解GC-先导篇]]></title>
    <url>%2F2019%2F06%2F19%2FGC-brief-intro%2F</url>
    <content type="text"><![CDATA[这篇文章对GC做一个简要的介绍，主要涉及到GC的基础知识点，以及常用的GC算法的原理性描述及存在的缺点，对于部分算法我们会给出相应的解决方案。最后我们讲述如何对GC算法进行性能评估… GC机制 （先导篇）GC的基础概念GC的定义 GC是Garbage Collection的简称，中文我们称之为垃圾回收 ​ 在GC中，我们把程序中不用的内存空间称之为垃圾 GC的简介及历史​ 对于大多数编程语言，已经内置了垃圾回收机制（比如Java，JavaScript，Python），比较早期的编程语言比如C lang 和C plus 这两门语言需要编程人员进行内存管理，即需要显式进行内存的申请及手动的内存销毁。 ​ GC这一概念最早由Lisp之父John McCarthy在1960年在论文中提出，这篇论文主要设计到后面要描述的GC算法-标记清除算法，后续其它计算机人员又相继提出了引用计数算法，GC复制算法。之后的几十年到当代为人所知的算法，不过都是前面三种GC算法的组合应用衍生出的产物而已。目前主要介绍JS中最常用的两种GC算法 GC的任务 找到内存空间中的垃圾 回收垃圾，让内存空间重新得到利用 GC的优点 程序员无需手动进行内存管理，可以集中精力于编程工作 减少与内存相关Bug的出现（内存泄漏，垂悬指针） JS常用的GC算法标记清除算法JavaScript中最常用的垃圾收集方式就是标记清除。 当变量进入环境时（如函数中某个变量的声明），就将此变量标记为进入环境，当变量离开环境（如函数执行完毕），就将变量标记为离开环境。变量的具体标记方法在后续的文章会进行详细介绍，此处不必关注具体的标记方式。 JS中垃圾收集器会在运行时给内存中所有的变量进行标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记，并在此之后加上被加上标记的变量，把这些视为准备删除的变量，然后垃圾收集器完成内存清除工作 缺点 效率问题，标记和清除过程的效率都不高 空间问题，会产生大量不连续的内存碎片，导致当程序需要更大的内存空间时，不得不提前触发下一次垃圾回收操作 引用计数算法Javascript中另一种不常见的垃圾收集策略叫做引用计数算法。 引用计数，顾名思义，跟踪记录每个值的被引用次数。例如将一个引用数据类型的值赋值给一个变量，则这个值的引用次数就为1，当把这个值赋给其它更多的变量时，值的引用次数依次增加，同时对于这个值的引用的变量取得另一个引用的值，当前这个值引用次数减1，当某个值的引用次数为0时，说明在内存中没有变量可以访问到这块内存空间的值，当垃圾收集器下次运行的时候，就会引用次数为0的值内存空间进行释放。 缺点引用计数算法在提出之后，后续有学者指出其存在一定的缺点，即它无法回收循环引用 什么是循环引用？，请看下面示例 1234567function foo() &#123; const objectA = new Object(); const object B = new Object (); objectA.prop1 = B; objectB.prop2 = A;&#125;// objectA和objectB通过自己的属性相互引用 在上面例子中，这种问题导致函数执行完毕之后，objectA和objectB继续存在，它们的引用次数不为0，对应的内存空间无法回收，当函数多次调用时，导致大量内存空间无法回收，影响程序执行 如何解决？ 对于这种情况，最好在不使用它们的时候手动断开两个对象之前的连接 12objectA.prop1 = null;objectB.prop2 = null; 不过解除一个值的引用并不意味着自动回收该值的内存空间，解除引用的真正目的在于让值脱离执行环境，以便垃圾回收机制下次运行的时候将其回收 GC算法的性能评估吞吐量吞吐量就是单位时间内的处理能力。 举个例子，对内存空间大小为SIZE的内存进行管理，要花费的时间为A，那么吞吐量为SIZE/A 最大暂停时间GC算法在执行的过程中都会导致mutator暂停，最大暂停时间指的是因执行GC而暂停执行mutator的最长时间 注： mutator的实体就是应用程序 访问的局部性程序运行时，我们把所有的数据加载到内存中，当CPU访问数据时，把要使用的数据读取到缓存中去，同时把该数据附近的所有数据都一同读入缓存，从而压缩读取数据的时间。 具有引用关系的对象之间通常很可能存在连续访问的情况，利用程序访问的局部性原理这一特性，把具有引用关系的对象安排在堆中较近的位置，就能在缓存中提高想要读取到数据的概率，令mutator告诉运行。]]></content>
      <categories>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
