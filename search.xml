<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode-876. Middle of the Linked List]]></title>
    <url>%2F2020%2F10%2F28%2FLeetcode-876-Middle-of-the-Linked-List%2F</url>
    <content type="text"><![CDATA[这篇文章主要是记录个人对Leetcode-876. Middle of the Linked List题目相关的解题思路的分析以及给出基于不同编程的语言的具体实现，同时也会对题目做相应改动扩展并给出解决方案，提升个人编程思维能力及复习多门编程语言相关语法… DescriptionGiven a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: 12345Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge's serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: 123Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. Analysis问题描述关键词提取： 非空 单链表 长度在1~100之间 这道题需要我们获取链表的中间节点(如果是链表长度为偶数，则获取靠近链表尾部的中间节点)， 思路1: 从链表头部出发，一次遍历一个节点，问题关键点在于我们需要确定遍历的次数N。 以例子中的奇数链表[1, 2, 3, 4, 5]进行分析，head节点为1，我们最终需要获取到节点3， 遍历次数N为2 再以偶数链表[1, 2, 3, 4, 5, 6]进行分析，head节点为1，最终需要获取节点为4， 遍历次数N为3 通过对两种链表进行分析我们不难总结出以下规律(假设链表长度为M): N = 向下取整(M &gt;&gt; 1 ) 或者 N = 向下取整(M / 2 ) 接下来，我们按照N长度进行遍历即可。 复杂度分析： 时间复杂度 O(n) 空间复杂度 O(1) 思路2: 将链表转换成数组，我们只需要确定问题描述的中间节点的位置的索引即可 假设索引为N， 链表长度为M ， N与M的关系和思路1中一致。唯一不同的是，这一次我们需要引入临时数组来依次存储链表中每一个节点，然后利用数组的索引访问获取到相应节点即可 复杂度分析: 时间复杂度 O(n) 空间复杂度 O(n) 思路3: 利用快慢指针 快慢指针的思路是两个指针(fast,slow) 都从链表头部出发，快指针一次走两步，慢指针一次走1步，当快指针到达链表末尾时，快指针刚好到达链表中间。 (这个思想也可以用来判断链表是否有环) 复杂度分析: 时间复杂度 O(n) 空间复杂度O(1) Hint: 计算N值的时候，向下取整我们可以使用各个语言提供的数学函数，例如js中的Math.floor()。另外一个计算方法则是判断M的奇偶性，当M为奇数是 N = (M - 1) / 2 , M 为偶数时 N = M / 2 1let N = (M &amp; 1) === 0 ? M &gt;&gt; 1 : (M - 1) &gt;&gt; 1 这里稍微要注意一下的是我们判断奇偶和除以2采用的都是位运算, 同时要注意位运算优先级较低，最好使用括号扩起来。 Enhance假设我们调整一下问题的输出要求，链表长度为奇数时输出不变，链表长度为偶数时，输出靠近链表头部的中间节点，我们又该怎么处理呢？ 对于第一种方案和第二种方案处理起来很简单，请重点思考一下基于第三种方案的变动处理 SolutionJavascript 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var middleNode = function(head) &#123; let cur = head; const list_len = listNodeLength(head) let iter_len = (list_len &amp; 1) === 0 ? list_len &gt;&gt; 1 : (list_len - 1) &gt;&gt; 1; while(iter_len) &#123; cur = cur.next; iter_len--; &#125; return cur;&#125;;var listNodeLength = function(head) &#123; let count = 0; let cur = head; while(cur) &#123; cur = cur.next; count++; &#125; return count;&#125; Python2 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def middleNode(self, head): """ :type head: ListNode :rtype: ListNode """ def listNodeLength(head): count = 0 cur = head while cur: cur = cur.next count += 1 return count # length = listNodeLength(head) cur = head # iter_length = length &gt;&gt; 1 if (length &amp; 1) == 0 else (length - 1) &gt;&gt; 1 iter_length = listNodeLength(head) // 2 while iter_length: cur = cur.next iter_length -= 1 return cur 注意事项： python中没有++， — 这两种运算符 我们可以使用 += 1，-= 1 python 中没有三目运算符 即 a &gt; b ? c : d 但是我们可以使用 c if a &lt; b else d 来代替 python 单行注释使用的是# ，多行注释使用的是 &#39;&#39;&#39; &#39;&#39;&#39; 或 &quot;&quot;&quot; &quot;&quot;&quot; （PS: 好久没使用py，都忘记了 😭，习惯性使用 //） Python3 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def middleNode(self, head: ListNode) -&gt; ListNode: fast = slow = head; while fast and fast.next: fast = fast.next.next slow = slow.next return slow 注意事项： python中的与，或，非是 and, or, not 和其它编程语言 &amp;&amp;， ||，! 相对应 Go Enhance 输出版本 12345678910111213141516171819/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func middleNode(head *ListNode) *ListNode &#123; preHead := &amp;ListNode &#123; 0, head, &#125;; fast, slow := preHead, preHead; for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next; slow = slow.Next; &#125; return slow;&#125; 此处的解决方案是在head节点之前增加一个哨兵节点，然后从哨兵节点处开始遍历，即可得到我们所需的结果]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解GC-先导篇]]></title>
    <url>%2F2019%2F06%2F19%2FGC-brief-intro%2F</url>
    <content type="text"><![CDATA[这篇文章对GC做一个简要的介绍，主要涉及到GC的基础知识点，以及常用的GC算法的原理性描述及存在的缺点，对于部分算法我们会给出相应的解决方案。最后我们讲述如何对GC算法进行性能评估… GC机制 （先导篇）GC的基础概念GC的定义 GC是Garbage Collection的简称，中文我们称之为垃圾回收 ​ 在GC中，我们把程序中不用的内存空间称之为垃圾 GC的简介及历史​ 对于大多数编程语言，已经内置了垃圾回收机制（比如Java，JavaScript，Python），比较早期的编程语言比如C lang 和C plus 这两门语言需要编程人员进行内存管理，即需要显式进行内存的申请及手动的内存销毁。 ​ GC这一概念最早由Lisp之父John McCarthy在1960年在论文中提出，这篇论文主要设计到后面要描述的GC算法-标记清除算法，后续其它计算机人员又相继提出了引用计数算法，GC复制算法。之后的几十年到当代为人所知的算法，不过都是前面三种GC算法的组合应用衍生出的产物而已。目前主要介绍JS中最常用的两种GC算法 GC的任务 找到内存空间中的垃圾 回收垃圾，让内存空间重新得到利用 GC的优点 程序员无需手动进行内存管理，可以集中精力于编程工作 减少与内存相关Bug的出现（内存泄漏，垂悬指针） JS常用的GC算法标记清除算法JavaScript中最常用的垃圾收集方式就是标记清除。 当变量进入环境时（如函数中某个变量的声明），就将此变量标记为进入环境，当变量离开环境（如函数执行完毕），就将变量标记为离开环境。变量的具体标记方法在后续的文章会进行详细介绍，此处不必关注具体的标记方式。 JS中垃圾收集器会在运行时给内存中所有的变量进行标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记，并在此之后加上被加上标记的变量，把这些视为准备删除的变量，然后垃圾收集器完成内存清除工作 缺点 效率问题，标记和清除过程的效率都不高 空间问题，会产生大量不连续的内存碎片，导致当程序需要更大的内存空间时，不得不提前触发下一次垃圾回收操作 引用计数算法Javascript中另一种不常见的垃圾收集策略叫做引用计数算法。 引用计数，顾名思义，跟踪记录每个值的被引用次数。例如将一个引用数据类型的值赋值给一个变量，则这个值的引用次数就为1，当把这个值赋给其它更多的变量时，值的引用次数依次增加，同时对于这个值的引用的变量取得另一个引用的值，当前这个值引用次数减1，当某个值的引用次数为0时，说明在内存中没有变量可以访问到这块内存空间的值，当垃圾收集器下次运行的时候，就会引用次数为0的值内存空间进行释放。 缺点引用计数算法在提出之后，后续有学者指出其存在一定的缺点，即它无法回收循环引用 什么是循环引用？，请看下面示例 1234567function foo() &#123; const objectA = new Object(); const object B = new Object (); objectA.prop1 = B; objectB.prop2 = A;&#125;// objectA和objectB通过自己的属性相互引用 在上面例子中，这种问题导致函数执行完毕之后，objectA和objectB继续存在，它们的引用次数不为0，对应的内存空间无法回收，当函数多次调用时，导致大量内存空间无法回收，影响程序执行 如何解决？ 对于这种情况，最好在不使用它们的时候手动断开两个对象之前的连接 12objectA.prop1 = null;objectB.prop2 = null; 不过解除一个值的引用并不意味着自动回收该值的内存空间，解除引用的真正目的在于让值脱离执行环境，以便垃圾回收机制下次运行的时候将其回收 GC算法的性能评估吞吐量吞吐量就是单位时间内的处理能力。 举个例子，对内存空间大小为SIZE的内存进行管理，要花费的时间为A，那么吞吐量为SIZE/A 最大暂停时间GC算法在执行的过程中都会导致mutator暂停，最大暂停时间指的是因执行GC而暂停执行mutator的最长时间 注： mutator的实体就是应用程序 访问的局部性程序运行时，我们把所有的数据加载到内存中，当CPU访问数据时，把要使用的数据读取到缓存中去，同时把该数据附近的所有数据都一同读入缓存，从而压缩读取数据的时间。 具有引用关系的对象之间通常很可能存在连续访问的情况，利用程序访问的局部性原理这一特性，把具有引用关系的对象安排在堆中较近的位置，就能在缓存中提高想要读取到数据的概率，令mutator告诉运行。]]></content>
      <categories>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
</search>
